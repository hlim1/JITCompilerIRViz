"""
    This program identifies the intial nodes generated for bytecodes
    and keep a track of optimisation phases that each node is going through
    and what optimisation was applied to them.

    Example,
        $python3 -f <ascii.out> -n <line number to begin scanning> -a <node address>

    Author: Terrence J. Lim
"""
import os
import re
import sys
import argparse

# Code to import modules from other directories.
# Soruce: https://codeolives.com/2020/01/10/python-reference-module-in-parent-directory/
currentdir = os.path.dirname(os.path.realpath(__file__))
parentdir = os.path.dirname(currentdir)
sys.path.append(parentdir)

import X86ASM as X86
import PhaseIdentifier
import FunctionLists as FL

# REGEX
BETWEEN_BRACKET_REGEX = "\[(.*?)\]"
OP_REGEX = "[\+\-\*\/]"

# List of X86 operations.
CONNECT_INPUT_PTR = "49 8b 7c b5 00"
ARGUMENT_PUSHES = [
        "41 54",
        "41 55",
        "41 56",
        "41 57",
]
EXCEPTION = "EXCEPTION"

def instruction_splitter(inst_line: str) -> list:
    """This function splits and clean up the instrcution line.
    The ascii file generated using updated trace2ascii under
    uacs-lynx conveniently delimited the line with semi-colons (;).

    args:
        inst_line (str): A single line of instruction read in from
        the ascii trace file.

    Structure:
        [0]: address,
        [1]: program,
        [2]: function,
        [3]: opcode and operands,
        [4]: asm instruction,
        [5:]: Memory and register access (R/W)


    returns:
        (list): a list holding splitted instruction.
    """

    idx = 0
    splitted_inst = []
    for elem in inst_line.split(';')[:-1]:
        if idx == 5:
            asm_inst = elem.strip().split(' ')
            asm = []
            mnemonics = ''.join(asm_inst[1:]).split(',')
            if len(mnemonics) > 2:
                for e in mnemonics:
                    ptr = re.search(BETWEEN_BRACKET_REGEX, e)
                    if ptr:
                        asm.append(f"[{ptr.group(1)}]")
                    else:
                        asm.append(e)
            else:
                asm = mnemonics

            splitted_inst.append({"asm_inst":[asm_inst[0], asm]})
        elif idx > 5:
            mem_accesses = elem.split(' ')[1:-1]
            for inst in mem_accesses:
                # Format example: ["R:RBP","0000000000000000"].
                # ["MW[7ffd30632e80]","0000000000000000"]
                splitted = inst.split('=')
                if (
                        "MR" in inst or
                        "MW" in inst
                ):
                    mem_access = handle_memory_RW(splitted)
                else:
                    mem_access = handle_register_RW(splitted)
                mem_access.append(splitted[-1])
                splitted_inst.append(mem_access)
        else:
            splitted_inst.append(elem.strip())
        idx += 1
    
    return splitted_inst[1:]

def handle_memory_RW(splitted: list) -> list:
    """This function splits the memory read and write
    operation into a separate list and return the refined
    format of list.

    args:
        splitted (list): a list of splitted memory read and write.

    returns:
        (list) refined list.
    """

    mem_access = []

    # For example: ["MW","7ffd30632e80]"].
    re_split = splitted[0].split("[")
    # For example: "mw".
    mem_access.append(re_split[0].lower())
    # For example: "7ffd30632e80"
    mem_access.append(re_split[1].strip(']'))

    return mem_access

def handle_register_RW(splitted: list) -> list:
    """This function splits the register read and write
    operation into a separate list and return the refined
    format of list.

    args:
        splitted (list): a list of splitted register read and write.

    returns:
        (list) refined list.
    """
    reg_access = []

    # Format example: r.
    reg_access.append(splitted[0].split(':')[0].lower())
    # Format example: rbp.
    reg_access.append(splitted[0].split(':')[1].lower())

    return reg_access

def get_all_nodes(lines: list, start_from: int):
    """This function goes through all optimisation phases start
    from the GraphBuilderPhase to the end of file and collect
    all generated new nodes.

    args:
        lines (list): list of raw instruction lines.
        start_from (int): line number to start scanning.

    returns:
        (list) list of collected node addresses.
    """

    AllNodes = []
    is_new = False
    line_number = start_from

    for line in lines[start_from:]:
        if EXCEPTION in line:
            return AllNodes
        re_inst = instruction_splitter(line)
        line_number += 1

        try:
            # New nodes are generated by "Node::New" function,
            # so we can ignore all other functions for the performance.
            if re_inst[2] != FL.NEW_STR:
                continue
        except:
            assert False, f"ERROR: List index out of range - Line: {line_number}; {line}"

        if re_inst[3] == "55":
            # X86 opcode '55' is a function entry indication.
            # Therefore, set the is_new flag to True to start
            # analysing the instructions.
            is_new = True
        elif re_inst[3] == "c3":
            # X86 opcode 'c3' is a function return.
            # Therefore, reset the is_new flag to False to end
            # the analysis.
            is_new = False

        # Register 'rax' is where generated nodes are being stored for the caller function
        # to access. However, 'rax' can be used for other purposes as well, so if we let
        # the tool to collect the 'rax' value until the New()'s last write rax, we can
        # get the node address.
        if is_new and re_inst[4]["asm_inst"][0] == "mov" and re_inst[4]["asm_inst"][1][0] == "rax":
            node = None
            for op in re_inst[5:]:
                if op[0] == "w" and op[1] == "rax":
                    node = op[2]
            assert (
                    node
            ), f"ERROR: Node is empty - {line}"
            AllNodes.append(node)

    return AllNodes

def optimisation_tracker(lines: list, phase_scope: dict, number: int, address: str):
    """This function tracks all optimisation phases applied to each node
    and return the dictionary of tracked optimisation phases mapped to
    each node.

    args:
        lines (list): trace lines in list.
        phase_scope (dict): scope of each phase.
        number (int): line number to begin scanning.
        address (str): address of target node to track optimisation.

    returns:
        (dict) phases that the node passed through.
        (dict) newly generated nodes during optimised phases.
        (dict) nodes that were referenced to genrate the new node.
        (dict) optimisation phased that actually applied optimisation to the node.
    """

    # Track the phases of the target node is going through.
    phases = {}
    # Track the new node(s) that was generated from the original node.
    generated_nodes = {}
    # Track the list of nodes used to generate new node.
    ref_nodes = {}
    # Tracks the phases that optimisation was actually taken place on the node.
    optimised_phases = {address:[]}

    target_addr = address
    has_newnode = False
    line_number = number
    prev_function = None
    last_phase = None
    for raw_line in lines[number:]:
        phase = get_current_phase(line_number, phase_scope)

        line_number += 1
        # If phase is None, then the line is an instruction that can be
        # disregarded. So, simply skip to next line.
        if not phase:
            continue

        re_inst = instruction_splitter(raw_line)
        
        function = re_inst[2]
        X86Op = re_inst[3]
        asm_inst = re_inst[4]["asm_inst"]
        rw_insts = re_inst[5:]

        if function == FL.NEWNODE_STR or re_inst[2] == FL.CLONENODE_STR:
            if has_newnode:
                node_addr = None
                for op in re_inst[5:]:
                    if op[1] == "rax":
                        node_addr = op[2]
                        break
                if target_addr in ref_node:
                    ref_nodes[node_addr] = ref_node
                    generated_nodes[phase] = node_addr
                    optimised_phases[node_addr] = [phase]
                    optimised_phases[target_addr] = [phase]
                    # Update target address to seek in the rest
                    # of optimisation phases.
                    target_addr = node_addr
                has_newnode = False

        if function == FL.NEW_STR:
            if X86Op == X86.PUSH_RBP:
                ref_node = []
            elif X86Op in ARGUMENT_PUSHES:
                reg = asm_inst[1][0]
                for op in re_inst[5:]:
                    if op[1] == reg and op[2] not in ref_node:
                        ref_node.append(op[2])
            elif X86Op == X86.RET[1]:
                has_newnode = True
        else:
            pass
        
        found = is_accessing_node(rw_insts, target_addr)

        if found:
            if target_addr not in phases and phase != last_phase:
                phases[target_addr] = [phase]
            elif target_addr in phases and phase not in phases[target_addr]:
                phases[target_addr].append(phase)
            
            func_name = function.split("::")[-1]
            # Identify the phases that actual optimisation is taking place.
            # Each optimisation functions use VisitNode function to visit the node
            # that require an optimisation.
            if func_name == "VisitNode":
                if (
                        target_addr in optimised_phases
                        and phase not in optimised_phases[target_addr]
                        and phase != "InstructionSelectionPhase"
                ):
                    optimised_phases[target_addr].append(phase)
            last_phase = phase
        else:
            pass

        prev_function = function


    return phases, generated_nodes, ref_nodes, optimised_phases

def is_accessing_node(accessing_insts: list, address: str):
    """This function simply checks whether the current instruction
    is accessing the node or not.

    args:
        accessing_insts (list): memory and register accessing
        instructions.
        address (str): target node's address.

    returns:
        (boolean) True, if the instruction is accessing node.
        Else, False.
    """

    found = False
    for inst in accessing_insts:
        # For now, we only care either the instruction is accessing
        # the node or not. A more precise analysis, such as reading
        # and writing, will be done in the future if we find how and
        # what can we use the information for.
        if inst[2] == address:
            found = True

    return found

def get_mr(accessing_insts: list):
    """This function returns mr list, if exists.

    args:
        accessing_insts (list): memory and register accessing
        instructions.

    returns:
        (list) ["mr", _address_, _value_] list.
        (None) if mr does not exist.
    """

    for inst in accessing_insts:
        if inst[0] == "mr":
            return inst

    return None

def get_current_phase(line_number: int, phase_scope: dict):
    """This function identifies the optimisation phase, if
    any, that the current trace line instruction belongs.
    Then, it returns the phase name.

    args:
        line_number (int): trace line number of current
        trace instruction.
        phase_Scope (dict): a dictionary holding scope
        information of each optimisation phase.

    returns:
        (str) current phase name that the instruction belongs.
        Else, None will be returned.
    """

    current_phase = None
    for phase, scope in phase_scope.items():
        if line_number > scope[0] and line_number < scope[1]:
            current_phase = phase

    return current_phase

def initial_node_identifier(bytecode_info: dict, lines: list):
    """This function automatically identify the initial nodes generated during
    the GraphBuilderPhase after bytecode offset setting.

    args:
        bytecode_info (dict): dictionary holding bytecode information.
        {address: [opcode, bytecode, size]}
        lines (list): a sublist of the trace that lines are only belongs to
        GraphBuilderPhase after bytecode offset setting.

    returns:
        (dict) bytecode address-to-JS node address dictionary.
        (dict) JS node address-to-input node addresses dictionary.
    """

    is_new           = False    # Flag to indicate Node::New function was entered.
    current_bytecode = None     # Temp. holder to hold current bytecode.
    prev_inst        = None     # Temp. holder to hold previous instruction.
    initial_nodes    = {}       # Dict. of initial nodes for each bytecode.
    input_nodes      = {}       # Dict. of inputs nodes to the new nodes.
    gen_nodes        = []       # List of generated nodes.
    inputs           = []       # List of input nodes.
    input_count      = 0        # Number of input nodes to generate a new node.

    for line in lines:
        re_inst = instruction_splitter(line)

        # If current instruction function is "current_bytecode", which
        # is a function to identify and mark next target bytecode to generate
        # the JS node. Then, update the local current_bytecode variable.
        if (
                (re_inst[2] == FL.VERSION_REF
                or re_inst[2] == FL.CURRENT_BYTECODE_STR)
                and re_inst[4]["asm_inst"][0] == "mov"
        ):
                mr = get_mr(re_inst[5:])
                if mr and mr[1] in bytecode_info:
                    current_bytecode = mr[1]

        # With the current_bytecode variable holding the bytecode array index address
        # and "NewNode" or "NewNodeUnchecked" is encountered,
        if (
                (re_inst[2] == FL.NEWNODE_STR or re_inst[2] == FL.NEWNODEUNCHECKED_STR)
                and current_bytecode
        ):
            if is_new:
                # if the is_newnode and already marked to True and the previous
                # instruction was "Node::New" function's return, 
                if (
                        prev_inst[2] == FL.NEW_STR
                        and prev_inst[4]["asm_inst"][0] == "ret"
                ):
                    # then we get the new node address by retrieving
                    # the value stored in the accumulator (rax). 
                    for op in re_inst[5:]:
                        if op[1] == "rax":
                            # Final Node of the graph "End" overwrites the "Return"
                            # node, so the below code breaks out once the "Return"
                            # node was collected.
                            if (
                                    current_bytecode in initial_nodes
                                    and bytecode_info[current_bytecode][0] == "ab"
                            ):
                                break
                            initial_nodes[current_bytecode] = op[2]
                            input_nodes[op[2]] = inputs
                            gen_nodes.append(op[2])

                    # Then, set is_new booleans to False and empty out inputs.
                    is_new = False
                    inputs = []
            else:
                # Identify the instruction of function parameter
                # int input_count passed to Node::New function.
                if re_inst[4]["asm_inst"][1][0] == "ecx":
                    for op in re_inst[5:]:
                        if op[1] == "rcx":
                            input_count = int(op[2], 16)

        if (
                input_count > 0
                and is_new
                and re_inst[2] == FL.NEW_STR
                and re_inst[4]["asm_inst"][0] == "mov"
                and re_inst[3] == CONNECT_INPUT_PTR
        ):
            get_input_nodes(re_inst[5:], gen_nodes, inputs)

        if (
                not is_new
                and re_inst[2] == FL.NEW_STR
        ):
            is_new = True

        prev_inst = re_inst

    # Clean input nodes. This is not the best way to do it, but for now
    # I will keep this way and update it later.
    tmp = {}
    for node, ipts in input_nodes.items():
        tmp[node] = []
        for ipt in ipts:
            if ipt in list(initial_nodes.values()):
                tmp[node].append(ipt)
    input_nodes = tmp

    # Convert initial nodes to dictionary type.
    initial_nodes = {"nodes":list(initial_nodes.values())}

    return initial_nodes, input_nodes

def get_input_nodes(insts: list, gen_nodes: list, inputs: list):
    """This function updates the inputs list with
    with the input nodes to generate the current node.

    args:
        inst (list): list of memory and register access instructions.
        gen_nodes (list): list of all generated nodes for bytecodes.
        inputs (list): empty list to hold input node addresses.

    returns:
        None.
    """

    non_bytecode_nodes = [] # List to hold input nodes, but that are not bytecode nodes,
                            # such as JSStackCheck or Start nodes. This has no use for now,
                            # but I'm collecting it for the possible future usage.

    for inst in insts:
        if inst[0] == "mr" and inst[2] not in inputs:
            if inst[2] in gen_nodes:
                inputs.append(inst[2])
            else:
                non_bytecode_nodes.append(inst[2])

    # Uncomment it if a usage is found.
    # return non_bytecode_nodes

# =============================================================================================

def argument_parser():
    """This function is for a safe command line
    input. It should receive the trace file name,
    line number in the trace file to start scanning,
    and the address of target node.

    returns:
        (str) file name.
        (int) line number.
        (str) address of target number.
    """

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-f",
        "--file",
        type=str,
        help="An input trace file."
    )
    parser.add_argument(
        "-n",
        "--number",
        type=str,
        help="Line number to begin scanning."
    )
    parser.add_argument(
        "-a",
        "--address",
        type=str,
        help="Target node address."
    )
    args = parser.parse_args()

    return args.file, args.number, args.address

def read_file(filename: str) -> list:
    """This function open and read lines in the file,
    if a file exists. If the file does not exist, then
    it prints out an error message.

    args:
        filename (str): Target file to open and load.

    returns:
        (list) a list of lines loaded from the file.
    """

    try:
        with open(filename) as f:
            return f.readlines()
    except IOError as x:
        if x.errno == errno.ENOENT:
            assert False, "Error(" + str(errno.ENOENT) + "). " + filename + ' - does not exist'
        elif x.errno == errno.EACCES:
            assert False, "Error(" + str(errno.EACCESS) + "). " + filename + ' - cannot be read'
        else:
            assert False, "Error(" + str(x.errno) + "). " + filename + ' - some other error'

# =============================================================================================

if __name__ == "__main__":
    filename, number, address = argument_parser()
    lines = read_file(filename)
    phase_scope, has_exception, line_number = phase_identifier.phase_identifier(lines)
    phases, generated_nodes, ref_nodes, opt_phases = optimisation_tracker(lines, phase_scope, number, address)

    for node, phase_list in phases.items():
        print (f"Node [{node}] passed {phase_list} phase(s)")
        if node in opt_phases:
            print (f"Node [{node}] was optimised in {opt_phases[node]} phase(s)\n")
        for phase in phase_list:
            if phase in generated_nodes:
                addr = generated_nodes[phase]
                print (f"Node [{addr}] generated during [{phase}] phase")
                if addr in ref_nodes:
                    for node_addr in ref_nodes[addr]:
                        print (f"Referenced node(s): {node_addr}")
